#!/bin/bash

# -------------------------------------------------------------------------------------------------------
# 통합 분석 스크립트 (결과를 파일로 저장)
# 사용법: ./analyze_to_file.sh [출력파일명]
# -------------------------------------------------------------------------------------------------------

OUTPUT_FILE=${1:-analysis_output.txt} # 첫 번째 인수가 없으면 기본 파일명 사용
LOG_DIR=$(pwd)
echo "------------------------------------------------------------------------------------------" > "$OUTPUT_FILE"
echo "✅ Zeek 로그 통합 분석 시작: $LOG_DIR" >> "$OUTPUT_FILE"
echo "결과 파일: $OUTPUT_FILE" >> "$OUTPUT_FILE"
echo "------------------------------------------------------------------------------------------" >> "$OUTPUT_FILE"

# 파일 존재 여부 확인
if [ ! -f "$LOG_DIR/conn.log" ]; then
    echo "오류: conn.log 파일을 찾을 수 없습니다. 현재 디렉터리: $LOG_DIR" >> "$OUTPUT_FILE"
    exit 1
fi


# -------------------------------------------------------------------------------------------------------
# [1] 프로토콜/응답 포트별 연결 수 Top 10
# -------------------------------------------------------------------------------------------------------
echo "### 1. 프로토콜/응답 포트별 연결 수 Top 10 (Protocol/Resp_Port)" >> "$OUTPUT_FILE"
cat conn.log | zeek-cut proto id.resp_p | sort | uniq -c | sort -nr | head -n 10 >> "$OUTPUT_FILE"
echo "------------------------------------------------------------------------------------------" >> "$OUTPUT_FILE"


# -------------------------------------------------------------------------------------------------------
# [2] 서버 이름별 연결 수 Top 10 (SSL/TLS 통신 대상)
# -------------------------------------------------------------------------------------------------------
echo "### 2. 서버 이름별 연결 수 Top 10 (SSL/TLS Server Name)" >> "$OUTPUT_FILE"
if [ -f "$LOG_DIR/ssl.log" ]; then
    cat ssl.log | zeek-cut server_name | sort | uniq -c | sort -nr | head -n 10 >> "$OUTPUT_FILE"
else
    echo "경고: ssl.log 파일이 없어 분석을 건너뜁니다." >> "$OUTPUT_FILE"
fi
echo "------------------------------------------------------------------------------------------" >> "$OUTPUT_FILE"


# -------------------------------------------------------------------------------------------------------
# [3] 시간대별 활동량 (막대 그래프)
# -------------------------------------------------------------------------------------------------------
echo "### 3. 시간대별 활동량 시각화 (Hour vs. Count)" >> "$OUTPUT_FILE"
cat conn.log | zeek-cut ts | awk '{print strftime("%H", $1)}' | sort | uniq -c | sort -k2 -n | awk '
{
    count = $1; 
    hour = $2;
    len = int(count / 1000); 
    bar = "";
    if (len == 0 && count > 0) { len = 1; }
    for(i=1; i<=len; i++) { bar = bar "*"; }
    printf "[%s] %8d %s\n", hour, count, bar;
}
' >> "$OUTPUT_FILE"
echo "------------------------------------------------------------------------------------------" >> "$OUTPUT_FILE"


# -------------------------------------------------------------------------------------------------------
# [4] 비정상 종료 연결 상태 Top (SF 제외)
# -------------------------------------------------------------------------------------------------------
echo "### 4. 비정상 종료 연결 상태 Top (SF: 정상 종료 제외)" >> "$OUTPUT_FILE"
cat conn.log | zeek-cut conn_state | grep -v 'SF' | sort | uniq -c | sort -nr >> "$OUTPUT_FILE"
echo "------------------------------------------------------------------------------------------" >> "$OUTPUT_FILE"


# -------------------------------------------------------------------------------------------------------
# [5] 데이터 전송량 Top 10 (GB/MB/KB 단위 포함)
# -------------------------------------------------------------------------------------------------------
echo "### 5. 데이터 전송량 Top 10 (Total/Client Tx/Server Tx - 단위 자동 변환)" >> "$OUTPUT_FILE"

cat conn.log | zeek-cut id.resp_h orig_bytes resp_bytes ts | awk '
function hr_bytes(bytes) {
    if (bytes >= 1073741824) return sprintf("%.2fGB", bytes / 1073741824);
    if (bytes >= 1048576) return sprintf("%.2fMB", bytes / 1048576);
    if (bytes >= 1024) return sprintf("%.2fKB", bytes / 1024);
    return sprintf("%dB", bytes);
}
NR>1 {
    total_bytes = $2 + $3;
    total_size_hr = hr_bytes(total_bytes);
    orig_size_hr = hr_bytes($2);
    resp_size_hr = hr_bytes($3);

    printf "%s %s %s %s %s %s\n", total_bytes, total_size_hr, $1, orig_size_hr, resp_size_hr, $4 
}
' | sort -k1 -nr | head -n 10 | awk '
BEGIN {
    printf "%-12s %-10s %-18s %-12s %-12s %s\n", "Total Size", "Resp_IP", "Client Tx (Orig)", "Server Tx (Resp)", "TS (Timestamp)", " "
    printf "------------------------------------------------------------------------------------------------\n"
}
{
    printf "%-12s %-10s %-18s %-12s %-12s %s\n", $2, $3, $4, $5, $6, ""
}
' >> "$OUTPUT_FILE"
echo "------------------------------------------------------------------------------------------" >> "$OUTPUT_FILE"


# -------------------------------------------------------------------------------------------------------
# [6] 서버 응답량 (resp_bytes) 분포 Top 10
# -------------------------------------------------------------------------------------------------------
echo "### 6. 서버 응답량 분포 Top 10 (MB 단위)" >> "$OUTPUT_FILE"
cat conn.log | zeek-cut resp_bytes | awk 'NR>1 {print int($1 / 1024 / 1024) "MB"}' | sort | uniq -c | sort -nr | head -n 10 >> "$OUTPUT_FILE"
echo "------------------------------------------------------------------------------------------" >> "$OUTPUT_FILE"


# -------------------------------------------------------------------------------------------------------
# [7] 평균 연결 지속 시간
# -------------------------------------------------------------------------------------------------------
echo "### 7. 평균 연결 지속 시간 (Average Duration)" >> "$OUTPUT_FILE"
cat conn.log | zeek-cut duration | awk '
NR>1 {sum += $1; count++} 
    END {print "평균 연결 지속 시간:", sum/count, "초"}' >> "$OUTPUT_FILE"
echo "==========================================================================================" >> "$OUTPUT_FILE"
echo "분석이 완료되었습니다. 결과 파일: $OUTPUT_FILE"
